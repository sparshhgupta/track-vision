{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  default: () => equal\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/helpers.ts\nfunction isOfType(type) {\n  return value => typeof value === type;\n}\nvar isFunction = isOfType(\"function\");\nvar isNull = value => {\n  return value === null;\n};\nvar isRegex = value => {\n  return Object.prototype.toString.call(value).slice(8, -1) === \"RegExp\";\n};\nvar isObject = value => {\n  return !isUndefined(value) && !isNull(value) && (isFunction(value) || typeof value === \"object\");\n};\nvar isUndefined = isOfType(\"undefined\");\n\n// src/index.ts\nfunction equalArray(left, right) {\n  const {\n    length\n  } = left;\n  if (length !== right.length) {\n    return false;\n  }\n  for (let index = length; index-- !== 0;) {\n    if (!equal(left[index], right[index])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalArrayBuffer(left, right) {\n  if (left.byteLength !== right.byteLength) {\n    return false;\n  }\n  const view1 = new DataView(left.buffer);\n  const view2 = new DataView(right.buffer);\n  let index = left.byteLength;\n  while (index--) {\n    if (view1.getUint8(index) !== view2.getUint8(index)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalMap(left, right) {\n  if (left.size !== right.size) {\n    return false;\n  }\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n  for (const index of left.entries()) {\n    if (!equal(index[1], right.get(index[0]))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalSet(left, right) {\n  if (left.size !== right.size) {\n    return false;\n  }\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equal(left, right) {\n  if (left === right) {\n    return true;\n  }\n  if (left && isObject(left) && right && isObject(right)) {\n    if (left.constructor !== right.constructor) {\n      return false;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n      return equalArray(left, right);\n    }\n    if (left instanceof Map && right instanceof Map) {\n      return equalMap(left, right);\n    }\n    if (left instanceof Set && right instanceof Set) {\n      return equalSet(left, right);\n    }\n    if (ArrayBuffer.isView(left) && ArrayBuffer.isView(right)) {\n      return equalArrayBuffer(left, right);\n    }\n    if (isRegex(left) && isRegex(right)) {\n      return left.source === right.source && left.flags === right.flags;\n    }\n    if (left.valueOf !== Object.prototype.valueOf) {\n      return left.valueOf() === right.valueOf();\n    }\n    if (left.toString !== Object.prototype.toString) {\n      return left.toString() === right.toString();\n    }\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) {\n      return false;\n    }\n    for (let index = leftKeys.length; index-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(right, leftKeys[index])) {\n        return false;\n      }\n    }\n    for (let index = leftKeys.length; index-- !== 0;) {\n      const key = leftKeys[index];\n      if (key === \"_owner\" && left.$$typeof) {\n        continue;\n      }\n      if (!equal(left[key], right[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (Number.isNaN(left) && Number.isNaN(right)) {\n    return true;\n  }\n  return left === right;\n}","map":{"version":3,"names":["src_exports","__export","default","equal","module","exports","__toCommonJS","isOfType","type","value","isFunction","isNull","isRegex","Object","prototype","toString","call","slice","isObject","isUndefined","equalArray","left","right","length","index","equalArrayBuffer","byteLength","view1","DataView","buffer","view2","getUint8","equalMap","size","entries","has","get","equalSet","constructor","Array","isArray","Map","Set","ArrayBuffer","isView","source","flags","valueOf","leftKeys","keys","rightKeys","hasOwnProperty","key","$$typeof","Number","isNaN"],"sources":["../src/index.ts","../src/helpers.ts"],"sourcesContent":["import { isObject, isRegex } from './helpers';\n\n/**\n * Check if arrays are equal.\n */\nfunction equalArray(left: unknown[], right: unknown[]) {\n  const { length } = left;\n\n  if (length !== right.length) {\n    return false;\n  }\n\n  for (let index = length; index-- !== 0; ) {\n    if (!equal(left[index], right[index])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check if array buffers are equal.\n */\nfunction equalArrayBuffer(left: ArrayBufferView, right: ArrayBufferView) {\n  if (left.byteLength !== right.byteLength) {\n    return false;\n  }\n\n  const view1 = new DataView(left.buffer);\n  const view2 = new DataView(right.buffer);\n\n  let index = left.byteLength;\n\n  while (index--) {\n    if (view1.getUint8(index) !== view2.getUint8(index)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check if maps are equal.\n */\nfunction equalMap(left: Map<unknown, unknown>, right: Map<unknown, unknown>) {\n  if (left.size !== right.size) {\n    return false;\n  }\n\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n\n  for (const index of left.entries()) {\n    if (!equal(index[1], right.get(index[0]))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check if sets are equal.\n */\nfunction equalSet(left: Set<unknown>, right: Set<unknown>) {\n  if (left.size !== right.size) {\n    return false;\n  }\n\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks if two values are equal.\n */\nexport default function equal(left: unknown, right: unknown) {\n  if (left === right) {\n    return true;\n  }\n\n  if (left && isObject(left) && right && isObject(right)) {\n    if (left.constructor !== right.constructor) {\n      return false;\n    }\n\n    if (Array.isArray(left) && Array.isArray(right)) {\n      return equalArray(left, right);\n    }\n\n    if (left instanceof Map && right instanceof Map) {\n      return equalMap(left, right);\n    }\n\n    if (left instanceof Set && right instanceof Set) {\n      return equalSet(left, right);\n    }\n\n    if (ArrayBuffer.isView(left) && ArrayBuffer.isView(right)) {\n      return equalArrayBuffer(left, right);\n    }\n\n    if (isRegex(left) && isRegex(right)) {\n      return left.source === right.source && left.flags === right.flags;\n    }\n\n    if (left.valueOf !== Object.prototype.valueOf) {\n      return left.valueOf() === right.valueOf();\n    }\n\n    if (left.toString !== Object.prototype.toString) {\n      return left.toString() === right.toString();\n    }\n\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n\n    if (leftKeys.length !== rightKeys.length) {\n      return false;\n    }\n\n    for (let index = leftKeys.length; index-- !== 0; ) {\n      if (!Object.prototype.hasOwnProperty.call(right, leftKeys[index])) {\n        return false;\n      }\n    }\n\n    for (let index = leftKeys.length; index-- !== 0; ) {\n      const key = leftKeys[index];\n\n      if (key === '_owner' && left.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (!equal(left[key], right[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Number.isNaN(left) && Number.isNaN(right)) {\n    return true;\n  }\n\n  return left === right;\n}\n","import { AnyObject, Primitive } from './types';\n\n/**\n * Checks if the value is of a specified type.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isOfType<T extends Primitive | Function>(type: string) {\n  // eslint-disable-next-line valid-typeof\n  return (value: unknown): value is T => typeof value === type;\n}\n\n/**\n * Checks if the value is a JavaScript function.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = isOfType<Function>('function');\n\n/**\n * Check if the value is null.\n */\nexport const isNull = (value: unknown): value is null => {\n  return value === null;\n};\n\n/**\n * Checks if the input is a regular expression.\n */\nexport const isRegex = (value: unknown): value is RegExp => {\n  return Object.prototype.toString.call(value).slice(8, -1) === 'RegExp';\n};\n\n/**\n * Checks if the value is an object.\n */\nexport const isObject = (value: unknown): value is AnyObject => {\n  return !isUndefined(value) && !isNull(value) && (isFunction(value) || typeof value === 'object');\n};\n\n/**\n * Checks if the value is undefined.\n */\nexport const isUndefined = isOfType<undefined>('undefined');\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}